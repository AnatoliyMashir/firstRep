Вы наверное недоумеваете, почему один и тот же файлик распихан по всем папкам?
А потому что иначе вы файлик readme не видите в упор, игнорируете сообщения в гихабе и на почту.
Поэтому это сообщение будет продублированно всеми возможными способами, кроме почты россии)

Пункт 1. Проверьте деккера
g++ -lpthread -O0 dekker.c
g++ -lpthread -O0 dekker_mfencr.c - на всякий случай продублирую и файлами сборки, вдруг опять не дойдет.
и да она не виснет, просто с mfence ооооочень долго работает, ставьте меньшие значения в потоках.

Пункт 2. Сколько надо баллов на допуск? или надо просто сдать все задачи?

Ответы:
1. Зачем постоянно переконфигурировать терминал? Но это ладно. Терминалами
мы не занимались, хто Ваше личное творчество. Однако на будущее: не нужно так
поступать. Это и не эффективно, и может к ошибкам приводить.

re 1:
если предложите иной способ обработать нажатие пробела силами сишника, без асмовых вставок,
я буду только рад. П.С. curses.h и getch не предлагать - очень уже там потом надо с выводом упахиваться.

2.Вообще совсем не понятны рассуждения о том, зачем Вам понадобился mutex.
Кэши, вообще-то, синхронизируются автоматически. А если Вам нужно было
убеждаться, что информация о записи в переменную дошла до другого процессора,
то для этого есть mfence.

re2:
лок/анлок вызывает гарантированый сброс в память.
mfence - простой процессора, по истечении которого кэш стухает и происходит синхронизация память-кэш
вы действительно хотите такие тормоза в реальных приложениях?

3.Эх. perror тоже пишет в stderr. Поэтому нет смысла писать3

if(fprintf (stderr, "%s\n","i can't unlock mutex")==-1) {
perror(printfErrorMessage);
}

Если первое не сработало, то второе тоже не сработает. И вообще у Вас код
очень сложный, а эти конструкции, одинаковые, постоянно повторяются.
Почему нельзя это всё было в виде отдельной функции оформить?

re3:
Ваша школа, вы мне еще на сдаче первой задачи сказали(эх жаль в классе, записи нету), что надо сначала нормально сругаться, print'ом, 
но принт может выдать ошибку - тогда сругаться perror'ом. Если проследите историю задач, увидите что во всех
используется подобная конструкция, вас это как то не насторожило.
	Насчет того, что можно оформить в функцию - да можно, но я бы, раз уж вы подняли этот вопрос, писал бы просто 
perror. Разрешаете? Ругаться опять не будете? Переделал на perror

4. Ну вот право же. Зачем такая гиперсложная система? Нити, сигналы, активные
ожидания. К чему это всё? Это же пустое усложнение. А специально усложнять и
без того сложные системы - это разве разумно? Зачем Вам это?

Плюс куча ошибок в этих черезмерно усложнённых потоках данных. Вот это Вам
зачем?

key='q';
lock=ask;
pthread_exit(&bad);

Это типа такой изящный способ завесить второй поток, который крутится в
while(lock == ask)? И вообще всю программу, потому что join не завершится? Так
написали бы сразу же while(true); и не мучались бы.

re4:
вам правда не нравится, что программа может корректно завершить работу, и подчистить за собой, даже если произошел сбой?
Честно, очень удивлен.

5. А сигналы? Эх. Отдельная песня. Вот делаете вы pthread_exit, а сигнал
оставляете старым. Программа висит, таймер тикает, пересчёт вызывается,
загрузка процессора 100% - это вы специально решили помочь системным
администраторам сварить кофе на процессоре?

re5:
сигналы свернуться при завершении приложения, в противном случае - почему тогда не подчищаем за собой в задаче 2?

6. И я что-то не вижу доказательства того, что обработчик сигнала увидит,
что lock изменился. Каким образом Вы гарантируете, что сигнал не вызовется,
во время того, что вы делаете

lock = current

и что

if(next == lock)

Будет отражать тот ход выполнения, который Вы запланировали? Почему lock
обработчик увидит обязательно вот этот, изменённый, а не старый? И не снесёт
тем самым тот буффер, который печатается в данный момент.

re6:
да, согласен, не учел специфику вызова сигнала в пуле потоков. +делал скидку как все, что присваивание атомарно.
Исправил

